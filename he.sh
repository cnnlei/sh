#!/bin/bash

#===================================================================================
# 脚本名称: he_tunnel_manager_final_v26.sh
# 脚本功能: (OpenSSL最终版) 移除xxd依赖, 改用openssl生成随机数, 兼容性更强
#           - [终极修复] 依赖检查不再需要xxd/vim-common, 随机生成功能改用openssl
#           - ... (包含之前所有功能)
# 使用方法: sudo ./he_tunnel_manager_final.sh
#===================================================================================

# --- 全局配置 ---
WORK_DIR="/he"
CONFIG_NAME="he.sh"
CONFIG_FILE_PATH="${WORK_DIR}/${CONFIG_NAME}"
INTERFACE_NAME="he-ipv6"
ROUTE_TABLE_ID="100"
LA_SERVER_IP="66.220.18.42"

# --- x-ui 联动配置 ---
XUI_DB_PATH="/etc/x-ui/x-ui.db"
XUI_SERVICE_NAME="x-ui"
XUI_OUTBOUND_TAGS=("he-ipv6" "warp")

# --- 批量IP配置 ---
PRESET_SUFFIXES=(
    "1790:3aa9:df4:711d:f961" "b1d:ecf4:bf23:b5eb:febe" "10af:8a9f:3375:179:4ad4"
    "849c:fd25:1ee2:f5d2:b0e5" "3008:786:ed4d:38c6:165f" "ac:94dc:6c4f:9081:1d9b"
    "aca:1388:4333:40d3:ff04" "30f7:a488:2a6c:9237:f234" "f8bc:22ee:5fd:764d:699b"
    "3293:a4b8:892f:294f:42da" "bbf3:8b50:5ced:e666:c7ea" "9ce9:593a:cb42:f169:a1ae"
    "e943:e1f5:4c96:7ff:48d1" "fbbd:6773:7e53:27dc:c99e" "41d0:c0d7:9e1a:2646:723f"
    "d5e0:6735:223c:4fa7:49c4" "bbb5:11d:2096:77e0:48bd" "d041:34b4:d6ea:25a4:95a4"
    "5e4d:27dd:4cb6:f94:e0bf" "5903:ed2d:948e:65a4:1326"
)

SERVERS=(
    "66.220.18.42"    "美国, 洛杉矶 (Los Angeles, CA)"
    "216.66.80.30"    "美国, 弗里蒙特 (Fremont, CA)"
    "216.66.84.42"    "美国, 阿什本 (Ashburn, VA)"
    "64.62.200.2"     "美国, 纽约 (New York, NY)"
    "216.66.87.14"    "美国, 芝加哥 (Chicago, IL)"
    "66.220.7.82"     "美国, 迈阿密 (Miami, FL)"
    "216.66.88.98"    "美国, 达拉斯 (Dallas, TX)"
    "216.66.86.114"   "美国, 西雅图 (Seattle, WA)"
    "209.51.181.2"    "英国, 伦敦 (London, UK)"
    "195.10.195.10"   "德国, 法兰克福 (Frankfurt, DE)"
    "216.66.22.2"     "荷兰, 阿姆斯特丹 (Amsterdam, NL)"
    "216.66.38.58"    "瑞士, 苏黎世 (Zurich, CH)"
    "103.56.233.1"    "日本, 东京 (Tokyo, JP)"
    "184.105.251.94"  "中国, 香港 (Hong Kong)"
    "184.105.220.102" "新加坡 (Singapore)"
)
# --- 全局配置结束 ---


#================================================
# 函数 1: 检查并安装依赖
#================================================
check_dependencies() {
    echo "🔎 正在检查依赖..."
    local missing_deps=()
    command -v ip &> /dev/null || missing_deps+=("iproute2")
    command -v awk &> /dev/null || missing_deps+=("awk")
    command -v jq &> /dev/null || missing_deps+=("jq")
    command -v sqlite3 &> /dev/null || missing_deps+=("sqlite3")
    command -v openssl &> /dev/null || missing_deps+=("openssl")

    if [ ${#missing_deps[@]} -eq 0 ]; then
        echo "✔︎ 所有依赖已满足。"
        return 0
    fi

    echo "⚠️ 缺少依赖: ${missing_deps[*]}"
    read -p "是否尝试自动安装? (Y/n): " install_choice
    if [[ "$install_choice" =~ ^[nN]$ ]]; then
        echo "❌ 用户取消安装。脚本无法继续。"
        return 1
    fi

    echo "正在尝试安装依赖..."
    local install_packages="iproute2 gawk jq sqlite3 openssl"
    if command -v apt-get &> /dev/null; then
        apt-get update && apt-get install -y $install_packages
    elif command -v yum &> /dev/null; then
        yum install -y iproute2 gawk jq sqlite openssl
    elif command -v dnf &> /dev/null; then
        dnf install -y iproute2 gawk jq sqlite openssl
    else
        echo "❌ 无法识别的包管理器。"
        return 1
    fi

    if command -v openssl &> /dev/null && command -v sqlite3 &> /dev/null && command -v jq &> /dev/null; then
        echo "✔︎ 依赖安装成功！"
        return 0
    else
        echo "❌ 依赖安装失败。"
        return 1
    fi
}


#================================================
# 函数 2: 生成标准的配置文件模板
#================================================
generate_config_template() {
    cat <<EOF > "$CONFIG_FILE_PATH"
#!/bin/bash
# HE.net IPv6 Tunnel Configuration Script
# Generated by he_tunnel_manager script
# --- Variables (由管理脚本修改) ---
REMOTE_IPV4="66.220.18.42"
IPV6_ROUTED_64_SEGMENT="c:fa"
IPV6_ROUTED_48_SEGMENT="f1c0"
# --- Static definitions (由管理脚本生成) ---
INTERFACE_NAME="${INTERFACE_NAME}"
ROUTE_TABLE_ID="${ROUTE_TABLE_ID}"
LOCAL_IPV4=\$(ip -4 route get 8.8.8.8 | awk '{print \$7}' | head -n 1)
# --- Clean up previous configuration ---
echo "Cleaning up old tunnel configuration..."
if ip link show \$INTERFACE_NAME &> /dev/null; then ip link set dev \$INTERFACE_NAME down; ip tunnel del \$INTERFACE_NAME; fi
ip -6 rule del from 2001:470:\${IPV6_ROUTED_64_SEGMENT}::/64 table \$ROUTE_TABLE_ID &> /dev/null
ip -6 rule del from 2001:470:\${IPV6_ROUTED_48_SEGMENT}::/48 table \$ROUTE_TABLE_ID &> /dev/null
ip -6 route flush table \$ROUTE_TABLE_ID &> /dev/null
# --- Setup new configuration ---
echo "Setting up new tunnel on interface '\$INTERFACE_NAME'..."
ip tunnel add \$INTERFACE_NAME mode sit remote \${REMOTE_IPV4} local \${LOCAL_IPV4} ttl 255
ip link set dev \$INTERFACE_NAME up
ip addr add 2001:470:\${IPV6_ROUTED_64_SEGMENT}::2/64 dev \$INTERFACE_NAME
ip addr add 2001:470:\${IPV6_ROUTED_48_SEGMENT}:6666:6666:6666:6666:6666/48 dev \$INTERFACE_NAME
ip link set dev \$INTERFACE_NAME mtu 1280
# --- Setup routing ---
echo "Setting up routing rules..."
ip -6 route add default via 2001:470:\${IPV6_ROUTED_64_SEGMENT}::1 dev \$INTERFACE_NAME table \$ROUTE_TABLE_ID
ip -6 rule add from 2001:470:\${IPV6_ROUTED_64_SEGMENT}::/64 table \$ROUTE_TABLE_ID
ip -6 rule add from 2001:470:\${IPV6_ROUTED_48_SEGMENT}::/48 table \$ROUTE_TABLE_ID
echo "Configuration applied."
EOF
}


#================================================
# 函数 3: 交互式编辑给定的配置文件
#================================================
interactive_edit_tunnel() {
    local config_path="$1"
    local current_64=$(grep 'IPV6_ROUTED_64_SEGMENT=' "$config_path" | cut -d'"' -f2)
    local current_48=$(grep 'IPV6_ROUTED_48_SEGMENT=' "$config_path" | cut -d'"' -f2)
    local current_ip=$(grep 'REMOTE_IPV4=' "$config_path" | cut -d'"' -f2)
    if [ -z "$current_64" ] || [ -z "$current_48" ] || [ -z "$current_ip" ]; then
        echo "❌ 错误: 无法解析 '$config_path' 文件。"
        return 1
    fi
    echo "=================================================="
    echo "    交互式 HE.net IPv6 隧道配置更新工具"
    echo "=================================================="
    local current_location="未知"
    for ((i=0; i<${#SERVERS[@]}; i+=2)); do
        if [[ "${SERVERS[i]}" == "$current_ip" ]]; then
            current_location="${SERVERS[i+1]}"
            break
        fi
    done
    echo "正在编辑文件: $config_path"
    echo "当前配置值如下:"
    echo "  - /64 地址段: $current_64"
    echo "  - /48 地址段: $current_48"
    echo "  - 隧道服务器: $current_ip ($current_location)"
    echo "--------------------------------------------------"
    echo "请输入新的配置值。如果某项不想更改，可直接回车。"
    echo
    read -p "➡️ 请输入新的 /64 地址段 (例如 c:fa) [$current_64]: " new_64
    [ -z "$new_64" ] && new_64=$current_64
    read -p "➡️ 请输入新的 /48 地址段 (例如 f1c0) [$current_48]: " new_48
    [ -z "$new_48" ] && new_48=$current_48
    local new_ip=$current_ip
    local perform_ip_change=false
    if [[ "$current_ip" != "$LA_SERVER_IP" ]]; then
        read -p "⚠️ 当前服务器不是洛杉矶, 要更换吗? (y/N): " choice
        if [[ "$choice" =~ ^[yY] ]]; then
            perform_ip_change=true
        fi
    else
        perform_ip_change=true
    fi
    if $perform_ip_change; then
        echo
        echo "--- 请从以下列表中选择新的隧道服务器 ---"
        for ((i=0; i<${#SERVERS[@]}; i+=2)); do
            local idx=$((i/2 + 1))
            printf " %2d. %-15s %s\n" "$idx" "${SERVERS[i]}" "${SERVERS[i+1]}"
        done
        echo "-------------------------------------------"
        local current_idx_str=""
        for ((i=0; i<${#SERVERS[@]}; i+=2)); do
            if [[ "${SERVERS[i]}" == "$current_ip" ]]; then
                current_idx_str="默认: $((i/2 + 1))"
                break
            fi
        done
        read -p "➡️ 请输入序号 [$current_idx_str]: " new_idx
        if [[ "$new_idx" =~ ^[0-9]+$ ]] && [ "$new_idx" -ge 1 ] && [ "$new_idx" -le $((${#SERVERS[@]}/2)) ]; then
            new_ip=${SERVERS[($new_idx-1)*2]}
        else
            echo "ℹ️ 输入无效或为空, 保持当前IP不变。"
        fi
    fi
    echo "--------------------------------------------------"
    echo "最终配置如下:"
    echo "  - 新 /64 段: $new_64"
    echo "  - 新 /48 段: $new_48"
    echo "  - 新服务器IP: $new_ip"
    echo "--------------------------------------------------"
    read -p "确认要将以上更改写入 '$config_path' 吗？(Y/n): " confirm
    if [[ "$confirm" =~ ^[nN]$ ]]; then
        echo "🚫 操作已取消。"
        return 1
    fi
    echo "⚙️ 正在更新配置文件: $config_path ..."
    sed -i.bak -e "s/REMOTE_IPV4=\".*\"/REMOTE_IPV4=\"$new_ip\"/" -e "s/IPV6_ROUTED_64_SEGMENT=\".*\"/IPV6_ROUTED_64_SEGMENT=\"$new_64\"/" -e "s/IPV6_ROUTED_48_SEGMENT=\".*\"/IPV6_ROUTED_48_SEGMENT=\"$new_48\"/" "$config_path"
    echo "✔︎ 配置文件更新完毕！原始文件已备份为 ${config_path}.bak"
    export FINAL_NEW_48_SEGMENT=$new_48
    return 0
}


#================================================
# 函数 4: 【v30 终极交互修复版】更新 x-ui 配置
#================================================
update_xui_config() {
    local new_48_segment="$1"
    local new_ipv6_addr=""
    local tags_to_update=()

    # --- 交互式向导 Part 1: 选择要使用的IP地址 ---
    echo
    echo "--- 联动更新 x-ui 向导 ---"
    echo "是否要更新 x-ui 出站的发送地址 (sendThrough)?"
    echo "  y) 是, 使用约定地址 (...:${new_48_segment}:6666:6666:6666:6666:6666)"
    echo "  e) 是, 从 he-ipv6 网卡上已有的地址中选择一个"
    echo "  n) 否, 跳过本次 x-ui 更新"
    echo "  q) 退出整个脚本"
    read -p "请选择 [y/e/n/q, 直接回车默认为 n]: " choice

    case "$choice" in
        y|Y)
            new_ipv6_addr="2001:470:${new_48_segment}:6666:6666:6666:6666:6666"
            echo "  -> 已选择使用约定地址: ${new_ipv6_addr}"
            ;;
        e|E)
            echo "  -> 正在扫描 ${INTERFACE_NAME} 网卡上的可用IPv6地址..."
            readarray -t AVAILABLE_IPS < <(ip -6 addr show dev "${INTERFACE_NAME}" 2>/dev/null | grep 'scope global' | awk '{print $2}' | cut -d'/' -f1)
            
            if [ ${#AVAILABLE_IPS[@]} -eq 0 ]; then
                echo "  -> ❌ 错误: 在 ${INTERFACE_NAME} 网卡上未找到任何可用的公网IPv6地址。无法继续。"
                return
            fi

            echo "  -> 找到以下可用地址:"
            for i in "${!AVAILABLE_IPS[@]}"; do
                printf "    %d) %s\n" "$((i+1))" "${AVAILABLE_IPS[i]}"
            done
            
            read -p "请输入您想使用的地址序号: " ip_choice
            if [[ "$ip_choice" =~ ^[0-9]+$ ]] && [ "$ip_choice" -ge 1 ] && [ "$ip_choice" -le ${#AVAILABLE_IPS[@]} ]; then
                new_ipv6_addr="${AVAILABLE_IPS[$ip_choice-1]}"
                echo "  -> 已选择地址: ${new_ipv6_addr}"
            else
                echo "  -> ❌ 错误: 无效的选择。跳过 x-ui 更新。"
                return
            fi
            ;;
        q|Q)
            echo "  -> 用户选择退出脚本。"
            exit 0
            ;;
        *) # 包括 n, N, 和直接回车
            echo "  -> 已跳过 x-ui 更新。"
            return
            ;;
    esac

    # --- 交互式向导 Part 2: 选择要更新的出站标签 ---
    if [ -n "$new_ipv6_addr" ]; then
        echo
        local default_tags_str=$(echo "${XUI_OUTBOUND_TAGS[*]}")
        read -p "➡️ 请输入要应用此IP的出站标签 (默认: ${default_tags_str}, 空格分隔): " user_tags
        
        if [ -z "$user_tags" ]; then
            tags_to_update=("${XUI_OUTBOUND_TAGS[@]}")
            echo "  -> 使用默认出站标签: (${tags_to_update[*]})"
        else
            read -r -a tags_to_update <<< "$user_tags"
            echo "  -> 使用自定义出站标签: (${tags_to_update[*]})"
        fi
        
        if [ ${#tags_to_update[@]} -eq 0 ]; then
            echo "  -> ⚠️ 未指定任何出站标签，跳过更新。"
            return
        fi
    else
        return
    fi

    # --- 核心数据库操作 ---
    echo; echo "🔄 开始联动更新 x-ui 数据库 (最终安全模式)..."
    if [ ! -f "$XUI_DB_PATH" ]; then echo "ℹ️ 未找到 x-ui 数据库文件: $XUI_DB_PATH。跳过更新。"; return; fi

    # 步骤1: 停止服务
    echo "  -> 步骤 1/4: 正在停止 '$XUI_SERVICE_NAME' 服务以安全读写数据库..."
    if systemctl is-active --quiet "$XUI_SERVICE_NAME"; then
        systemctl stop "$XUI_SERVICE_NAME"; sleep 1
    fi
    echo "  -> ✔︎ 服务已停止。"

    # 步骤2: 从 settings 表读取总配置
    echo "  -> 步骤 2/4: 正在从数据库 settings 表读取 xrayTemplateConfig..."
    local xray_config_json=$(sqlite3 "$XUI_DB_PATH" "SELECT value FROM settings WHERE key = 'xrayTemplateConfig';")
    if [ -z "$xray_config_json" ]; then echo "  -> ❌ 错误: 未能在 settings 表中找到 xrayTemplateConfig。正在重启服务..."; systemctl start "$XUI_SERVICE_NAME"; return; fi

    # 步骤3: 使用 jq 修改
    echo "  -> 步骤 3/4: 正在使用 jq 在内存中更新出站配置..."
    local tags_json_array='['; for tag in "${tags_to_update[@]}"; do tags_json_array+="\"$tag\","; done; tags_json_array="${tags_json_array%,}]"
    local modified_xray_config_json=$(echo "$xray_config_json" | jq --argjson tags "$tags_json_array" --arg ip "$new_ipv6_addr" '( .outbounds[] | select(.tag | IN($tags[])) ) |= (.sendThrough = $ip)')
    
    # 步骤4: 写回数据库
    echo "  -> 步骤 4/4: 正在将修改后的完整配置写回数据库..."
    local escaped_json=$(echo "$modified_xray_config_json" | sed "s/'/''/g")
    sqlite3 "$XUI_DB_PATH" "UPDATE settings SET value = '${escaped_json}' WHERE key = 'xrayTemplateConfig';"
    if [ $? -ne 0 ]; then echo "❌ 使用 sqlite3 写回数据库失败！正在重启服务恢复..."; systemctl start "$XUI_SERVICE_NAME"; return; fi
    echo "  -> ✔︎ 数据库修改成功。"

    # 启动服务
    echo "  -> 正在启动 '$XUI_SERVICE_NAME' 服务..."
    systemctl start "$XUI_SERVICE_NAME"; sleep 2
    if systemctl is-active --quiet "$XUI_SERVICE_NAME"; then echo "✔︎ '$XUI_SERVICE_NAME' 服务已成功启动, 新配置已生效！"; else echo "❌ '$XUI_SERVICE_NAME' 服务启动失败！请手动检查: sudo systemctl status $XUI_SERVICE_NAME"; fi
}


#================================================
# 函数 5: 创建并启用 systemd 开机自启服务
#================================================
setup_systemd_service() {
    local service_name="he-tunnel.service"
    local service_path="/etc/systemd/system/${service_name}"
    if ! command -v systemctl &> /dev/null; then
        echo "ℹ️ 未检测到 systemd, 无法设置开机自启服务。"
        return
    fi
    if systemctl is-enabled "$service_name" &> /dev/null; then
        echo "ℹ️ 开机自启服务 ('$service_name') 已经启用, 无需重复设置。"
        return
    fi

    echo
    read -p "💡 是否要将 '$CONFIG_FILE_PATH' 设置为开机自启? (Y/n): " choice
    if [[ "$choice" =~ ^[nN]$ ]]; then
        echo "ℹ️ 用户选择不设置开机自启。"
        return
    fi

    echo "⚙️ 正在创建 systemd 服务: $service_path..."
    cat << EOF > "$service_path"
[Unit]
Description=HE.net IPv6 Tunnel Setup (managed by he_tunnel_manager script)
After=network-online.target
Wants=network-online.target
[Service]
Type=oneshot
ExecStart=$CONFIG_FILE_PATH
RemainAfterExit=yes
[Install]
WantedBy=multi-user.target
EOF

    echo "⚙️ 正在启用服务..."
    systemctl daemon-reload
    systemctl enable "$service_name"
    if systemctl is-enabled "$service_name" &> /dev/null; then
        echo "✔︎ 成功! '$CONFIG_FILE_PATH' 将在下次开机时自动运行。"
    else
        echo "❌ 错误: 设置开机自启失败。请检查 systemd 日志。"
    fi
}


#================================================
# 函数 6: 【已修正】主执行流程
#================================================
main() {
    if [ "$(id -u)" -ne 0 ]; then
        echo "❌ 错误：此脚本需要以 root 权限运行。"
        exit 1
    fi
    check_dependencies
    if [ $? -ne 0 ]; then
        exit 1
    fi
    echo "--------------------------------------------------"
    echo "⚙️ 准备工作环境..."
    mkdir -p "$WORK_DIR"
    if [ ! -f "$CONFIG_FILE_PATH" ]; then
        echo "  -> 配置文件 '$CONFIG_FILE_PATH' 不存在, 正在生成基础模板..."
        generate_config_template
        chmod +x "$CONFIG_FILE_PATH"
        echo "✔︎ 基础模板生成成功。"
    fi
    echo
    interactive_edit_tunnel "$CONFIG_FILE_PATH"
    if [ $? -ne 0 ]; then
        echo
        echo "❌ 编辑过程被取消或失败, 脚本已终止。"
        exit 1
    fi

    # --- 每次都执行批量添加IP的向导 ---
    # 1. 先清理掉旧的IP块, 避免重复添加
    awk '/# --- START BATCH ADDED IPS ---/{f=1;next} /# --- END BATCH ADDED IPS ---/{f=0;next} !f' "$CONFIG_FILE_PATH" > "${CONFIG_FILE_PATH}.tmp" && mv "${CONFIG_FILE_PATH}.tmp" "$CONFIG_FILE_PATH"

    echo
    echo "--- 批量添加 /48 地址向导 ---"
    echo "您可以选择将一批/48地址命令添加到 '$CONFIG_FILE_PATH' 的末尾。"
    echo "  1) 使用预设的、固定的后缀列表 (来自您的示例)"
    echo "  2) 随机生成一批新的后缀 (20个)"
    echo "  3) 本次不添加/更新批量地址"
    read -p "请选择后缀生成方式 [1-3, 直接回车默认为 1]: " suffix_choice

    local command_block=""
    # 注意: he.sh 脚本内部使用 $IPV6_ROUTED_48_SEGMENT 变量, 我们在这里生成命令时也必须使用它
    local he_sh_prefix_var="2001:470:\${IPV6_ROUTED_48_SEGMENT}"

    case "$suffix_choice" in
        2)
            echo "  -> 正在生成 20 个随机后缀..."
            generate_random_segment() { openssl rand -hex 2; }
            for (( i=1; i<=20; i++ )); do
                local suffix="$(generate_random_segment):$(generate_random_segment):$(generate_random_segment):$(generate_random_segment):$(generate_random_segment)"
                # 【已修正】使用转义的 \${INTERFACE_NAME}
                command_block+="sudo ip addr add ${he_sh_prefix_var}:${suffix}/48 dev \${INTERFACE_NAME};\n"
            done
            ;;
        3)
            echo "  -> 已选择不添加批量地址。"
            command_block=""
            ;;
        *) # 默认选项, 包括 1 和直接回车
            echo "  -> 正在使用 20 个预设后缀..."
            for suffix in "${PRESET_SUFFIXES[@]}"; do
                # 【已修正】使用转义的 \${INTERFACE_NAME}
                command_block+="sudo ip addr add ${he_sh_prefix_var}:${suffix}/48 dev \${INTERFACE_NAME};\n"
            done
            ;;
    esac
    
    # 如果生成了命令, 则将其追加到 he.sh 文件
    if [ -n "$command_block" ]; then
        # 添加标记, 以便下次清理
        echo -e "\n# --- START BATCH ADDED IPS ---" >> "$CONFIG_FILE_PATH"
        echo -e "$command_block" >> "$CONFIG_FILE_PATH"
        echo -e "# --- END BATCH ADDED IPS ---" >> "$CONFIG_FILE_PATH"
        echo "✔︎ 批量地址命令已成功更新到 '$CONFIG_FILE_PATH'。"
    fi
    # --- 向导结束 ---

    echo
    read -p "✅ 配置已更新, 是否立即执行 '$CONFIG_FILE_PATH' 来应用网络设置? (Y/n): " choice
    if [[ ! "$choice" =~ ^[nN]$ ]]; then
        echo "🚀 正在执行配置脚本..."
        echo "-------------------------------------------"
        bash "$CONFIG_FILE_PATH"
        echo "-------------------------------------------"
        echo "🎉 网络配置完成！"
        update_xui_config "$FINAL_NEW_48_SEGMENT"
        setup_systemd_service
        echo "🎉 所有操作完成！"
    else
        echo "ℹ️ 用户选择不执行。配置已保存在 '$CONFIG_FILE_PATH'。"
    fi
    exit 0
}

# --- 运行主函数 ---
main
